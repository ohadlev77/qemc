"""QAOAResult (dataclass) and QAOASolver classes."""

from typing import Any, Optional, List, Dict
from dataclasses import dataclass

import numpy as np
from scipy.optimize import minimize, OptimizeResult
from qiskit import QuantumCircuit, transpile
from qiskit.circuit.parametervector import ParameterVector
from qiskit.result.counts import Counts
from qiskit_aer import AerSimulator
from qiskit.providers.backend import Backend
from networkx import Graph

from qemc.classical_functions import compute_cut_score


@dataclass
class QAOAResult:
    """
    A container for data generated by the `QAOASolver.run` method.

    Attributes:
        optimizer_result (OptimizeResult): an abbreviation of the optimization
        process returned by `scipy.optimize.minimize`.
        appx_optimal_counts (Counts): the counts resulted from execution of the QAOA's
        Ansatz with the approximated optimal parameters.
    """

    optimizer_result: OptimizeResult
    appx_optimal_counts: Counts
    

class QAOASolver:
    """
    An interface for finding approximated solutions to the MaxCut
    problem for a given graph, using the QAOA algorithm.
    """

    def __init__(self, graph: Graph) -> None:
        """
        Args:
            graph (Graph): the graph we seek to approximate a MaxCut solution for.
        """

        self.graph = graph
        self.num_nodes = graph.number_of_nodes()

    def construct_ansatz(self, num_layers: int, meas: Optional[bool] = False) -> QuantumCircuit:
        """
        Constructs an Ansatz circuit for the given MaxCut problem.

        Args:
            num_layers (int): the number of repetitions over the block of the combined unitary
            cost and mixer operators. equivalent to the `p` parameter in the QAOA math notation.
            meas (bool): whether to add measurements in the end of the Ansatz, or not (default = False).

        Returns:
            (QuantumCircuit): the Ansatz circuit.
        """

        beta = ParameterVector("beta", length=num_layers)
        gamma = ParameterVector("gamma", length=num_layers)
        ansatz = QuantumCircuit(self.num_nodes)
        
        # Initial state |+>^n preparation
        ansatz.h(ansatz.qubits)

        # Applying the unitary cost and mixer operators, `num_layers` times
        for layer in range(num_layers):
            ansatz.barrier()

            # Cost operator
            for edge in self.graph.edges:
                ansatz.rzz(gamma[layer], edge[0], edge[1]) # 2 * gamma?
            ansatz.barrier()

            # Mixer operator
            ansatz.rx(2 * beta[layer], ansatz.qubits) # 2 * beta?

        if meas:
            ansatz.measure_all()
        
        return ansatz

    def compute_expectation_value(
        self,
        params: List[float]
    ) -> float:
        """
        Computes the expectation value of the MaxCut's cost Hamiltonian ("H_c").

        Args:
            assigned_ansatz (QuantumCircuit): the Ansatz circuit to run, with the parameters
            already assigned.

        Returns:
            (float): the expectation value of the cost Hamiltonian.
        """

        assigned_ansatz = self.ansatz.bind_parameters(params)
                                                      
        counts = self.backend.run(
            assigned_ansatz,
            shots=self.shots
        ).result().get_counts()

        exp_value = 0
        if self.shots == 0:
            for partition_bitstring, prob in counts.items():
                exp_value -= compute_cut_score(self.graph, partition_bitstring) * prob
        else:
            for partition_bitstring, count in counts.items():
                exp_value -= compute_cut_score(self.graph, partition_bitstring) * (count / self.shots)
        
        return exp_value
    
    def run(
        self,
        ansatz: QuantumCircuit,
        shots: int,
        backend: Backend,
        optimizer_method: str,
        x0: Optional[List[float]] = None,
        optimizer_options: Optional[Dict[Any, Any]] = None
    ) -> QAOAResult:
        """
        Executes the QAOA algorithm for the given MaxCut problem.

        Args:
            TODO CORRECT
            ansatz (QuantumCircuit): the Ansatz circuit.
            x0 (Optional[List[Union[int, float]]] = None): the initial value of the parameters.
            shots (Optional[Backend] = AerSimulator()): number of `assigned_ansatz` simulations executions.
            backend (Backend = AerSimulator()): backend to run simulations upon.
            optimizer_method (Optional[str] = "COBYLA"): optimizer to use (see docstrings
            of `scipy.optimize.minimize` for all available options).

        Returns:
            (QAOAResult): A packed data object contains the optimizer result and the counts
            of executing the Ansatz with the approximated optimal parameters `shots` times.
        """

        self.shots = shots
        self.backend = backend
        self.ansatz = ansatz

        # If an initial point `x0` is not defined, drawing a random one
        if x0 is None:
            x0 = [np.random.uniform(0, 2*np.pi) for _ in range(ansatz.num_parameters)]

        optimizer_result = minimize(
            fun=self.compute_expectation_value,
            x0=x0,
            method=optimizer_method,
            options=optimizer_options
        )

        # Simulating the Ansatz with the approximated optimal parameters
        appx_optimal_counts = sorted(
            backend.run(
                ansatz.bind_parameters(optimizer_result.x),
                shots=shots
            ).result().get_counts().items(),
            key=lambda count_tuple: count_tuple[1],
            reverse=True
        )

        return QAOAResult(optimizer_result, appx_optimal_counts)
    
    @staticmethod
    def compute_appx_ratio(exp_value: float, optimal_score: int) -> float:
        """
        Returns the approximation ratio `exp_value / optimal score`.
        """
        
        return exp_value / optimal_score