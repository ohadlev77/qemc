"""QAOAResult (dataclass) and MaxCutQAOA classes."""

from typing import Union, Optional, List
from dataclasses import dataclass

import numpy as np
from scipy.optimize import minimize, OptimizeResult
from qiskit import QuantumCircuit, transpile
from qiskit.circuit.parametervector import ParameterVector
from qiskit.result.counts import Counts
from qiskit_aer import AerSimulator
from qiskit.providers.backend import Backend
from qiskit.quantum_info import Pauli
from networkx import Graph

from qemc.classical_functions import compute_cut_score

@dataclass
class QAOAResult:
    """
    A container for data generated by the `MaxCutQAOA.run` method.

    Attributes:
        optimizer_result (OptimizeResult): an abbreviation of optimization process
        returned by `scipy.optimize.minimize`.
        appx_optimal_counts (Counts): the counts resulted from execution of the QAOA's Ansatz
        with the approximated optimal parameters.
    """

    optimizer_result: OptimizeResult
    appx_optimal_counts: Counts
    

class QAOASolver:
    """
    An interface for finding approximated solutions to the MaxCut
    problem for a given graph, using the QAOA algorithm.
    """

    def __init__(self, graph: Graph) -> None:
        """
        Args:
            graph (Graph): the graph we seek to apprxoimate a MaxCut solution for.
        """

        self.graph = graph
        self.num_nodes = graph.number_of_nodes()

    def construct_ansatz(self, num_layers: int) -> QuantumCircuit:
        """
        Constructs an Ansatz circuit for the given MaxCut problem.

        Args:
            num_layers (int): the number of repetitions over the block of the combined unitary
            cost and mixer operators. The original math-sign for `num_layers` is "p".

        Returns:
            (QuantumCircuit): the Ansatz circuit.
        """

        beta = ParameterVector("beta", length=num_layers)
        gamma = ParameterVector("gamma", length=num_layers)
        ansatz = QuantumCircuit(self.num_nodes)
        
        # Initial state |+>^n preparation
        ansatz.h(ansatz.qubits)

        # Applying the unitary cost and mixer operators, `num_layers` times
        for layer in range(num_layers):
            ansatz.barrier()

            # Cost operator
            for edge in self.graph.edges:
                ansatz.rzz(2*gamma[layer], edge[0], edge[1])            
            ansatz.barrier()

            # Mixer operator
            ansatz.rx(2*beta[layer], ansatz.qubits)

        ansatz.measure_all()
        
        return ansatz

    def compute_expectation_value(
        self,
        assigned_ansatz: QuantumCircuit,
        shots: Optional[int] = 1024,
        backend: Optional[Backend] = AerSimulator()
    ) -> float:
        """
        Computes the expectation value of the MaxCut's cost Hamiltonian ("H_c").

        Args:
            assigned_ansatz (QuantumCircuit): the Ansatz circuit to run, with the parameters
            already assigned.

        Returns:
            (float): the expectation value of the cost Hamiltonian.
        """

        counts = self.backend.run(
            transpile(assigned_ansatz, backend),
            shots=self.shots
        ).result().get_counts()

        exp_value = 0
        for counts_item in counts.items():
            exp_value += compute_cut_score(self.graph, counts_item[0]) * (counts_item[1] / shots)
        
        return exp_value
    
    def run(
        self,
        ansatz: QuantumCircuit,
        x0: Optional[List[Union[int, float]]] = None,
        shots: Optional[int] = 1024,
        backend: Optional[Backend] = AerSimulator(),
        optimizer_method: Optional[str] = "COBYLA"
    ) -> QAOAResult:
        """
        Executes the QAOA algorithm for the given MaxCut problem.

        Args:
            ansatz (QuantumCircuit): the Ansatz circuit.
            x0 (Optional[List[Union[int, float]]] = None): the initial value of the parameters.
            shots (Optional[Backend] = AerSimulator()): number of `assigned_ansatz` simulations executions.
            backend (Backend = AerSimulator()): backend to run simulations upon.
            optimizer_method (Optional[str] = "COBYLA"): optimizer to use (see docstrings
            of `scipy.optimize.minimize` for all available options).

        Returns:
            (QAOAResult): A packed data object contains the optimizer result and the counts
            of executing the Ansatz with the approximated optimal parameters `shots` times.
        """

        self.shots = shots
        self.backend = backend

        # The function to run in each iteration of the oprimizer. We use a minimizer so we add a minus
        fun_to_optimize = lambda param: -self.compute_expectation_value(
            ansatz.bind_parameters(param),
            shots,
            backend
        )

        # If an initial point `x0` is not defined, drawing a random one
        if x0 is None:
            x0 = [np.random.uniform(0, 2*np.pi) for _ in range(ansatz.num_parameters)]

        optimizer_result = minimize(fun=fun_to_optimize, x0=x0, method=optimizer_method)

        # Simulating the Ansatz with the approximated optimal parameters
        appx_optimal_counts = sorted(
            backend.run(
                transpile(ansatz.bind_parameters(optimizer_result.x), backend),
                shots=shots
            ).result().get_counts().items(),
            key=lambda count_tuple: count_tuple[1],
            reverse=True
        )

        return QAOAResult(optimizer_result, appx_optimal_counts)
    
    @staticmethod
    def compute_appx_ratio(exp_value: float, optimal_score: int) -> float:
        """
        Returns the approximation ratio `exp_value / optimal score`.
        """
        
        return exp_value / optimal_score